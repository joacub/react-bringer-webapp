import path from 'path';
import express from 'express';
import cors from 'cors';
// import 'react-hot-loader';
import React from 'react';
import ReactDOM from 'react-dom/server';
import morgan from 'morgan';
import favicon from 'serve-favicon';
import compression from 'compression';
import cookieParser from 'cookie-parser';
import httpProxy from 'http-proxy';
import PrettyError from 'pretty-error';
import http from 'http';
import { StaticRouter, Router } from 'react-router';
import { renderRoutes } from 'react-router-config';
import { createMemoryHistory } from 'history';
import { ChunkExtractor } from '@loadable/server';
import { trigger } from 'redial';
import config from 'config';
import createStore from 'redux/create';
import apiClient from 'helpers/apiClient';
import Html from 'helpers/Html';
import routes from 'routes';
import { createApp } from 'app';
import { waitChunks } from 'utils/chunks';
import asyncMatchRoutes from 'utils/asyncMatchRoutes';
import Provider from 'components/Provider/Provider';
import RouterTrigger from 'components/RouterTrigger/RouterTrigger';
import getPageContext from 'components/Context/createThemeContext';
// import blocked from 'blocked';
import humans from 'express-humans';
import dataLocaleEs from 'locales/es/common';
import Redis from '../api/utils/Redis';

// const expireTimeCookieLink = 1 * 365 * 24 * 60 * 60 * 1000;

// You can find a benchmark of the available CSS minifiers under
// https://github.com/GoalSmashers/css-minification-benchmark
// We have found that clean-css is faster than cssnano but the output is larger.
// Waiting for https://github.com/cssinjs/jss/issues/279
// 4% slower but 12% smaller output than doing it in a single step.
//
// It's using .browserslistrc
// let prefixer;
// let cleanCSS;

// if (process.env.NODE_ENV === 'production') {
//   const postcss = require('postcss');
//   const autoprefixer = require('autoprefixer');
//   const CleanCSS = require('clean-css');

//   prefixer = postcss([autoprefixer]);
//   cleanCSS = new CleanCSS();
// }

const langsData = {
  en: {},
  es: dataLocaleEs
};

// blocked(ms => {
//   console.warn('SERVER ------>>> event loop blocked for', ms, 'ms');
// });

// const chunksPath = path.join(__dirname, '..', 'static', 'dist', 'loadable-chunks.json');
// This is the stats file generated by webpack loadable plugin
const statsFile = path.join(__dirname, '..', 'static', 'dist', 'loadable-stats.json');
const pretty = new PrettyError();
// eslint-disable-next-line
process.on('unhandledRejection', (reason, p) => console.error('Unhandled Rejection at: Promise ', p, pretty.render(reason)));

const targetUrl = `http://${config.apiHost}:${config.apiPort}`;
const app = express();
const server = new http.Server(app);
const proxy = httpProxy.createProxyServer({
  target: targetUrl,
  ws: true
});

if (__DEVELOPMENT__) {
  app.use(morgan('dev', { skip: req => req.originalUrl.indexOf('/ws') !== -1 }));
  app.use(cors());
}

app
  .use(cookieParser())
  .use(compression())
  .use(Redis())
  .use(
    humans({
      header: 'Bringer',
      team: [
        {
          'Original developer': 'Bringer',
          Twitter: '@Bringer'
        },
      ],
      thanks: ['Node'],
      site: {
        Standards: 'HTML5, CSS3',
        Softwares: 'Visual Studio code'
      },
      note: 'Built with love by bringeraircargo.com.'
    })
  )
  .use(favicon(path.join(__dirname, '..', 'static', 'favicon.ico')))
  .use('/manifest.json', (req, res) => res.sendFile(path.join(__dirname, '..', 'static', 'manifest.json')));
app.use('/service-worker.js', (req, res) => {
  res.setHeader('Service-Worker-Allowed', '/');
  res.setHeader('Cache-Control', 'no-store');
  return res.sendFile(path.join(__dirname, '..', 'static', 'dist', 'service-worker.js'));
});

app.use('/sw-import.js', (req, res) => {
  res.setHeader('Service-Worker-Allowed', '/');
  res.setHeader('Cache-Control', 'no-store');
  return res.sendFile(path.join(__dirname, '..', 'static', 'dist', 'sw-import.js'));
});

app.use(express.static(path.join(__dirname, '..', 'static')));

app.use((req, res, next) => {
  const ip = req.headers['x-forwarded-for'] || req.headers['x-real-ip'] || req.ip;
  res.setHeader('X-Real-IP', ip);
  res.setHeader('X-Forwarded-For', ip);
  next();
});

// Proxy to API server
app.use('/api', (req, res) => {
  proxy.web(req, res, { target: targetUrl });
});

app.use('/oauth', (req, res) => {
  proxy.web(req, res, { target: `${targetUrl}/oauth` });
});

app.use('/ws', (req, res) => {
  proxy.web(req, res, { target: `${targetUrl}/ws` });
});

server.on('upgrade', (req, socket, head) => {
  proxy.ws(req, socket, head);
});

// added the error handling to avoid https://github.com/nodejitsu/node-http-proxy/issues/527
proxy.on('error', (error, req, res) => {
  if (error.code !== 'ECONNRESET') {
    console.error('proxy error', error);
  }

  if (!res.headersSent && typeof res.writeHead !== 'undefined') {
    res.writeHead(500, { 'content-type': 'application/json' });
  }

  const json = { error: 'proxy_error', reason: error.message };
  res.end(JSON.stringify(json));
});

app.use(async (req, res) => {
  if (__DEVELOPMENT__) {
    // Do not cache webpack stats: the script file would change since
    // hot module replacement is enabled in the development env
    webpackIsomorphicTools.refresh();
  }

  const _app = createApp(req);

  const providers = {
    client: apiClient(req),
    app: _app,
    restApp: _app
  };
  const history = createMemoryHistory({ initialEntries: [req.originalUrl] });

  const store = createStore({
    history,
    helpers: providers,
  });

  const helmetContext = {};

  function hydrate() {
    res.write('<!doctype html>');
    ReactDOM.renderToNodeStream(
      <Html helmetContext={helmetContext} assets={webpackIsomorphicTools.assets()} store={store} />
    ).pipe(res);
  }

  if (__DISABLE_SSR__) {
    return hydrate();
  }

  try {
    const { components, match, params } = await asyncMatchRoutes(routes, req.path);

    // const lang = params.lang || 'en';

    // const langs = {
    //   en: true,
    //   es: true
    // };

    // if (!Object.prototype.hasOwnProperty.call(langs, lang)) {
    //   res.redirect(301, `/en${req.originalUrl}`);
    // } else {
    const lang = req.acceptsLanguages('es', 'en') || 'en';
    providers.intl = { lang, messages: langsData[lang] };

    const triggerLocals = {
      ...providers,
      store,
      match,
      params,
      history,
      location: history.location
    };

    await Promise.resolve(providers.app.get('authentication')).catch(() => null);
    await trigger('inject', components, triggerLocals);
    await trigger('fetch', components, triggerLocals);

    const { settings } = store.getState();
    const pageContext = getPageContext(settings.uiTheme);

    const extractor = new ChunkExtractor({ statsFile });
    const context = {};
    const component = extractor.collectChunks(
      <Provider store={store} {...providers} pageContext={pageContext} helmetContext={helmetContext}>
        <Router history={history}>
          <StaticRouter location={req.originalUrl} context={context}>
            <RouterTrigger>{renderRoutes(routes)}</RouterTrigger>
          </StaticRouter>
        </Router>
      </Provider>
    );

    const content = ReactDOM.renderToString(pageContext.sheetsRegistry.collect(component));

    if (context.url) {
      return res.redirect(context.code || 301, context.url);
    }

    // const bundles = getBundles(getChunks(), modules);

    // You can now collect your script tags
    const scriptElements = extractor.getScriptElements(); // or extractor.getScriptElements();

    // You can also collect your "preload/prefetch" links
    const linkElements = extractor.getLinkElements(); // or extractor.getLinkElements();

    // And you can even collect your style tags (if you use "mini-css-extract-plugin")
    const styleElements = extractor.getStyleElements(); // or extractor.getStyleElements();

    const bundles = {
      scriptElements,
      linkElements,
      styleElements
    };

    // console.log(styleElements, 'styleelements');

    const assets = webpackIsomorphicTools.assets();

    let css = pageContext.sheetsRegistry.toString();
    if (process.env.NODE_ENV === 'production') {
      css = pageContext.sheetsRegistry.toString().replace(/(\r\n|\n|\r|  +)/gm, ' ');
    }
    // if (process.env.NODE_ENV === 'production') {
    //   const result1 = await prefixer.process(css, { from: undefined });
    //   ({ css } = result1);
    //   css = cleanCSS.minify(css).styles;
    // }

    const html = (
      <Html
        intl={providers.intl}
        helmetContext={helmetContext}
        assets={assets}
        bundles={bundles}
        content={content}
        store={store}
        styles={css}
        originalUrl={req.originalUrl}
      />
    );

    const code = context.code ? context.code : 200;

    // let Link = '';

    // if (bundles.linkElements) {
    //   bundles.linkElements.forEach(bundle => {
    //     if (Link === '') {
    //       Link += `<${bundle.key}>; rel=preload; as=script`;
    //     } else {
    //       Link += `, <${bundle.key}>; rel=preload; as=script`;
    //     }
    //   });
    // }

    // const cookieLink = req.cookies.linkPushed;
    // if (assets.styles) {
    //   Object.keys(assets.styles)
    //     .forEach(style => {
    //       if (style === 'main' && cookieLink !== assets.styles[style]) {
    //         res.cookie('linkPushed', assets.styles[style], { maxAge: expireTimeCookieLink, httpOnly: true });
    //         if (Link === '') {
    //           Link += `<${assets.styles[style]}>; rel=preload; as=style`;
    //         } else {
    //           Link += `, <${assets.styles[style]}>; rel=preload; as=style`;
    //         }
    //       }
    //     });
    // }

    // if (Link !== '') {
    //   res.setHeader('Link', Link);
    // }

    res.status(code).send(`<!doctype html>${ReactDOM.renderToString(html)}`);
    // }
  } catch (mountError) {
    console.error('MOUNT ERROR:', pretty.render(mountError));
    res.status(500);
    hydrate();
  }
});

(async () => {
  if (config.port) {
    try {
      // await Loadable.preloadAll();
      await waitChunks(statsFile);
      // We create an extractor from the statsFile
    } catch (error) {
      console.log('Server preload error:', error);
    }

    server.listen(config.port, err => {
      if (err) {
        console.error(err);
      }
      console.info(`Node.js Version: ${process.version}`);
      console.info('----\n==> ✅  %s is running, talking to API server on %s.', config.app.title, config.apiPort);
      console.info('==> 💻  Open http://%s:%s in a browser to view the app.', config.host, config.port);
    });

    process.on('SIGINT', () => {
      server.close(err => {
        process.exit(err ? 1 : 0);
      });
    });
  } else {
    console.error('==>     ERROR: No PORT environment variable has been specified');
  }
})();
